---
title: "cutouts"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{02: cutouts}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---



```{r simulation}
library(dplyr)

# Function to run a single simulation
run_simulation <- function(n) {
  # Generate data
  dat <- data.frame(
    treatment_status = rbinom(n = n, size = 1, prob = 0.5)
  ) |> 
    mutate(
      outcome = ifelse(treatment_status == 1, rnorm(n, 2, 1), rnorm(n, 1.5, 1)),
      cov_one = if_else(treatment_status == 1,
                        sample(2:5, replace = TRUE, size = n),
                        sample(1:4, replace = TRUE, size = n)),
      cov_two = if_else(treatment_status == 1,
                        rnorm(n, 5, 1),
                        rnorm(n, 3, 1))
    )
  
  # Calculate True Glass's Delta
  true_delta <- round(mean(dat$outcome[dat$treatment_status == 1]) - mean(dat$outcome[dat$treatment_status == 0]) / 
    sd(dat$outcome[dat$treatment_status == 0]),4)
  
  # Fit models and immediately summarize
  simple_model_summary <- summary(lm(outcome ~ treatment_status, data = dat))
  model_with_covs_summary <- summary(lm(outcome ~ treatment_status + cov_one + cov_two, data = dat))
  
  # Extract coefficients
  beta_simple <- simple_model_summary$coefficients["treatment_status", "Estimate"]
  beta_covs <- model_with_covs_summary$coefficients["treatment_status", "Estimate"]
  
  # Extract SE of intercept directly from summary objects
  se_intercept_simple <- simple_model_summary$coefficients["(Intercept)", "Std. Error"]
  se_intercept_covs <- model_with_covs_summary$coefficients["(Intercept)", "Std. Error"]
  
  # Calculate n_c
  n_c <- sum(dat$treatment_status == 0)
  
  # Estimate population SD using sqrt(n_c)
  estimated_sd_simple <- se_intercept_simple * sqrt(n_c)
  estimated_sd_covs <- se_intercept_covs * sqrt(n_c)
  estimated_delta_simple <- beta_simple / estimated_sd_simple
  estimated_delta_covs <- beta_covs / estimated_sd_covs
  
  # Return results
  return(data.frame(
    N = n,
    True_Glass_Delta = true_delta,
    simple_Delta = estimated_delta_simple,
    covs_Delta = estimated_delta_covs
  ))
}

# Function to run multiple simulations
simulate_effect_sizes <- function(n_values, num_simulations) {
  results <- lapply(n_values, function(n) {
    replicate(num_simulations, run_simulation(n), simplify = FALSE) |> bind_rows()
  }) |> bind_rows()
  return(results)
}

# Parameters for simulation
n_values <- c(50, 100, 500, 1000)
num_simulations <- 100

# Run simulations
simulation_results <- simulate_effect_sizes(n_values, num_simulations)

simulation_results |> 
  group_by(N) |> 
  summarise(
    Avg_True_d = round(mean(True_Glass_Delta), 3),
    avg_simple_delta = round(mean(simple_Delta),3),
    Avg_Cov_d_Diff = round(mean(covs_Delta),3))

```

as we can see, this method basically works only if there are no covariates. once you have informative covariates, no good.

```{r t-test-sim}
library(PaluckMetaSOP)
# Assuming this library has the d_calc function for converting t-test to Cohen's d

# Function to run a single simulation
run_simulation <- function(n) {
  # Generate data
  dat <- data.frame(
    treatment_status = rbinom(n = n, size = 1, prob = 0.5)
  ) |> 
    mutate(
      outcome = ifelse(treatment_status == 1, rnorm(n, 2, 1), rnorm(n, 1.5, 1)),
      cov_one = if_else(treatment_status == 1,
                        sample(2:5, replace = TRUE, size = n),
                        sample(1:4, replace = TRUE, size = n)),
      cov_two = if_else(treatment_status == 1,
                        rnorm(n, 5, 1),
                        rnorm(n, 3, 1))
    )
  
  # Calculate true mean differences and SD for true Cohen's d
  mean_t = mean(dat$outcome[dat$treatment_status == 1])
  mean_c = mean(dat$outcome[dat$treatment_status == 0])
  sd <- sd(dat$outcome)
  true_cohen_d = (mean_t - mean_c) / sd
  
  # Fit models and immediately summarize
  no_covs_t_value <- summary(lm(outcome ~ treatment_status, data = dat))$coefficients["treatment_status", "t value"]
  covs_t_value <- summary(lm(outcome ~ treatment_status + cov_one + cov_two, data = dat))$coefficients["treatment_status", "t value"]
  
  # Calculate n_t and n_c
  n_t <- sum(dat$treatment_status == 1)
  n_c <- sum(dat$treatment_status == 0)
  
  # Convert t-values to Cohen's d using 'd_calc'
  cohen_d_simple <- d_calc(stat_type = "t_test", stat = no_covs_t_value, n_t = n_t, n_c = n_c)
  cohen_d_covs <- d_calc(stat_type = "t_test", stat = covs_t_value, n_t = n_t, n_c = n_c)
  
  # Return results
  return(data.frame(
    N = n,
    True_Cohen_d = true_cohen_d,
    Cohen_d_Simple = cohen_d_simple,
    Cohen_d_Covs = cohen_d_covs
  ))
}

# Parameters for simulation
n_values <- c(50, 100, 500, 1000)
num_simulations <- 100

# Function to run multiple simulations
simulate_effect_sizes <- function(n_values, num_simulations) {
  results <- lapply(n_values, function(n) {
    replicate(num_simulations, run_simulation(n), simplify = FALSE) |> bind_rows()
  }) |> bind_rows()
  return(results)
}

# Run simulations
simulation_results <- simulate_effect_sizes(n_values, num_simulations)

simulation_results |> 
  group_by(N) |> 
  summarise(
    Avg_True_Cohen_d = round(mean(True_Cohen_d), 3),
    t_to_d_simple = round(mean(Cohen_d_Simple), 3),
    t_to_d_with_covs = round(mean(Cohen_d_Covs), 3)
  )
```

This is closer,
